#pragma once
#include <vector>

#define MAX_VERTEX_JOINT_BLENDS 4

namespace SEF
{
	template <typename T>
	struct Vector2
	{
		T x;
		T y;
	};

	template <typename T>
	struct Vector3
	{
		T x;
		T y;
		T z;
	};

	template <typename T>
	struct Vector4
	{
		T x;
		T y;
		T z;
		T w;
	};

	struct Matrix4f
	{
		float Properties[4][4];
	};

	struct Joint
	{
		std::string Name;
		Matrix4f GlobalBindPoseInverse;
		std::vector<uint32_t> Children;
	};

	struct Skeleton
	{
		std::string SkinName;
		std::vector<Joint> Joints;
	};

	struct JointData
	{
		uint32_t ID;
		float Weight;
	};

	struct VertexData
	{
		bool bHasUV;
		Vector2<float> UV;
		Vector3<float> Position;
		Vector3<float> Color;
		Vector3<float> Normal;
		Vector3<float> Tangent;
		Vector3<float> Binormal;
		Vector4<JointData> BlendInfo;
	};

	struct MeshData
	{
		std::string Name;
		std::vector<unsigned int> Indices;
		std::vector<VertexData> Vertices;
	};

	template<typename T>
	inline Vector2<T> InitVector2(const T& x, const T& y)
	{
		Vector2<T> retVal = {};
		retVal.x = x;
		retVal.y = y;

		return retVal;
	}

	template<typename T>
	inline Vector3<T> InitVector3(const T& x, const T& y, const T& z)
	{
		Vector3<T> retVal = {};
		retVal.x = x;
		retVal.y = y;
		retVal.z = z;

		return retVal;
	}

	template<typename T>
	inline Vector4<T> InitVector4(const T& x, const T& y, const T& z, const T& w)
	{
		Vector4<T> retVal = {};
		retVal.x = x;
		retVal.y = y;
		retVal.z = z;
		retVal.w = w;

		return retVal;
	}

	inline Matrix4f IdentityMatrix4f()
	{
		Matrix4f retVal = {};
		int count = 0;
		for (auto x = 0; x < 4; x++)
		{
			for (auto y = 0; y < 4; y++)
			{
				if (count % 5 == 0)
				{
					retVal.Properties[x][y] = 1.0f;
				}
				else
				{
					retVal.Properties[x][y] = 0.0f;
				}
				count++;
			}
		}
		return retVal;
	}

	inline bool AddBlendInfo(VertexData& vertex, const JointData& blendInfo)
	{
		bool result = false;
		if (vertex.BlendInfo.x.Weight == 0.0f)
		{
			vertex.BlendInfo.x = blendInfo;
			result = true;
		}
		else if (vertex.BlendInfo.y.Weight == 0.0f)
		{
			vertex.BlendInfo.y = blendInfo;
			result = true;
		}
		else if (vertex.BlendInfo.z.Weight == 0.0f)
		{
			vertex.BlendInfo.z = blendInfo;
			result = true;
		}
		else if (vertex.BlendInfo.w.Weight == 0.0f)
		{
			vertex.BlendInfo.w = blendInfo;
			result = true;
		}
		return result;
	}

	template<typename T>
	inline const bool IsEqual(const Vector2<T>& one, const Vector2<T>& two)
	{
		bool result = true;

		if (one.x != two.x)
			result = false;
		else if (one.y != two.y)
			result = false;

		return result;
	}

	template<typename T>
	inline const bool IsEqual(const Vector3<T>& one, const Vector3<T>& two)
	{
		bool result = true;

		if (one.x != two.x)
			result = false;
		else if (one.y != two.y)
			result = false;
		else if (one.z != two.z)
			result = false;

		return result;
	}

	template<typename T>
	inline const bool IsEqual(const Vector4<T>& one, const Vector4<T>& two)
	{
		bool result = true;

		if (one.x != two.x)
			result = false;
		else if (one.y != two.y)
			result = false;
		else if (one.z != two.z)
			result = false;
		else if (one.w != two.w)
			result = false;

		return result;
	}

	inline const bool IsEqual(const VertexData & one, const VertexData & two)
	{
		//No Discrimination by Tangents or Binormals due to being generated by these values

		bool uvs = IsEqual(one.UV, two.UV);
		bool normals = IsEqual(one.Normal, two.Normal);
		bool position = IsEqual(one.Position, two.Position);
		bool colors = IsEqual(one.Color, two.Color);

		if (position && normals && uvs && colors)
		{
			return true;
		}
		return false;
	}

	inline const bool IsEqual(const MeshData & one, const MeshData & two)
	{
		if (one.Vertices.size() != two.Vertices.size())
			return false;

		if (one.Indices.size() != two.Indices.size())
			return false;

		for (int it = 0; it < one.Vertices.size(); it++)
		{
			if (!IsEqual(one.Vertices[it], two.Vertices[it]))
			{
				return false;
			}
		}

		for (int it = 0; it < one.Indices.size(); it++)
		{
			if (one.Indices[it] != two.Indices[it])
			{
				return false;
			}
		}

		return true;
	}
}